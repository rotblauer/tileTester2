#!/usr/bin/env bash

## Specifics
# ^ tracks.db is bolt database for API that receives incoming tracks from mobile cat trackering devices. catmobileTracks ios.
#    those points are stored as struct trackPoint.TrackPoints.

# tldr
# dump.go runs tracks.db(bolty) through `$ tippecanoe` which builds sensible vector mbtiles
# that .mbtiles file is then transferred back to a bolt.db file and sent back up to serve.
#
# !tldr
# v tippecanoe is a C++ cli program that organizes and builds points to vector mbtiles. it does a lot of logic about how to show a lot of points cleverly. there are options.
#    data generated is in .mbtiles format and .json. .mbtiles is readable by a sqlite3 interface, and tile data is gzipped.
#
# last step of dump.go is undump/undump.go, which reads the .mbtiles/sqlite3 data back into a bolt.db
# that .db (named tippedcanoetrack.db by default) is then synced to the punktlich.rotblauer.com domain as tester.db
#
# punktlich runs a tile server (by default on port :8081?think).
# after running ./getem, you'll need to ssh freya and ./punktlich.rotblauer.com/kickstart for the changes to take effect

# "global" vars, parsed in 'getops' below
noupdatedb=0   # -n -- whether to prevent updating tracks.db from server, default false
noupdatedeps=0 # -s -- whether to prevent updating project dependencies (go get -u ...), default false
jumpto=''      # -x=[upload|syncfrom|cleanup] -- only use a certain part of the script functionality.
logprocess() {
	echo
	echo "------------------------------------------"
	date
	echo ">>> $1"
	echo
}

upload() {
	set -e # exit if any error
	logprocess "Running upload"
	# Gzip it for uploading
	logprocess "gzipping tippedcanoetrack.db -> tippedcanoetrack.db.gz for uploading..."
	gzip --best --keep --verbose ./tippedcanoetrack.db

	# sync newly created/update bolty db back to punktlich, finally
	logprocess "Syncing fresh bolt.db back to punktlich.rotblauer.com..."
	rsync -avzLPh ./tippedcanoetrack.db.gz freya:~/punktlich.rotblauer.com/tippedcanoetrack.db.gz #/tester.db

	# And update locally too for development.
	logprocess "Copying fresh tippedcanoetrack.db -> TileServer/tester.db..."
	cp tippedcanoetrack.db ./TileServer/tester.db

	logprocess "Replacing old db with new db on Freya and kickstarting tile server..."
	ssh freya <<\EOI
cd punktlich.rotblauer.com
gzip --decompress ./tippedcanoetrack.db.gz
mv ./tippedcanoetrack.db ./tester.db
./kickstart
exit
EOI
	i="$(date),$(whoami),$(hostname)"
	ssh freya 'echo '"$i"' >> punktlich.rotblauer.com/YOURSTRULY'
}

syncfrom() {
	# # The Overview
	# server tracks.db(bolt) -> local tippecanoe -> local out.mbtiles (+ out.json) -> local tippedcanoetrack.db(bolt) -> server punktlich.rotblauer.com/
	if [[ noupdatedb -eq 0 ]]; then

		# update copy of freya's tracks.db from which to sync from. this should keep
		# the version to sync from relatively static...? (as opposed to syncing from a "live" db)
		# also creates a defacto backup
		logprocess "Creating static copy of tracks.db on Freya"
		ssh freya <<\EOI
kill $(ps aux | grep "[t]rackermain" | awk '{print $2}')
cd track.areteh.co
echo "LOCK" > ./LOCK
rsync -avzLPhu ./db/tracks.db ./tracks.db.sync
rm -f ./LOCK
./kickstart
exit
EOI

		# make a backup/remove old local version. don't want any stragglers causing problems with bolt opening file.
		if [ -f ./tracks.db ]; then
			logprocess "Moving existing ./tracks.db -> ./tracks.db.gz"
			if [ -f ./tracks.db.gz ]; then mv ./tracks.db.gz ./tracks.db.gz.bak; fi
			if gzip -9 -v ./tracks.db && [ -f ./tracks.db.gz.bak ]; then rm ./tracks.db.gz.bak; fi
		fi
		# update tracks from API bolt.db on Freya to local
		logprocess "Syncing remote tracks.db.sync --> local ./tracks.db"
		rsync -avzLhP --delete freya:~/track.areteh.co/tracks.db.sync ./tracks.db #sync from upstream static copy
	else
		if [ ! -f ./tracks.db ]; then
			echo
			echo "!!! No local ./tracks.db found and -n flag used to prevent sync from freya. Exiting now."
			exit 1
		fi
		echo ">>> -n flag used: Skipping sync tracks.db from freya; using local tracks.db"
	fi
}

dumpify() {
	set -e # exit if any error
	logprocess "Beginning dump phase"
	rebuild=1
	if [[ -f "dumper" ]]; then
		read -p "Found pre-existing 'dumper' binary (built from dump.go). Rebuild? (y/n)? " choice
		case "$choice" in
		y | Y) echo ;;
		n | N) echo "Skipping rebuild of dump.go -> ./dumper ..." && echo && rebuild=0 ;;
		*) echo "Invalid choice." && exit 1 ;;
		esac
	fi
	if [[ rebuild -eq 1 ]]; then
		# Get and update all dependencies, eg. boltdb/bolt -> coreos/bbolt
		# use github as upstream remote "origin" because goggable dies on the reg now cuz the russians AND not https
		# you HAVE TO ensure that origin is available and secure
		if [[ noupdatedeps -eq 0 ]]; then
			logprocess "Updating and validating package dependencies from upstream..."
			echo -n "github.com/rotblauer/trackpoints: " && git --work-tree="$GOPATH/src/github.com/rotblauer/trackpoints" --git-dir="$GOPATH/src/github.com/rotblauer/trackpoints/.git" \
				branch --set-upstream-to=origin/master master
			echo -n ".: " && git branch --set-upstream-to=origin/master master
			go get -v -u github.com/rotblauer/tileTester2/...
		fi
		logprocess "Building ./dumper"
		go build -o dumper dump.go
	fi
	logprocess "Running dumper"
	./dumper
}

cleanup() {
	logprocess "Backing up and cleaning up old artifacts..."

	# Backup existing tracks.db to iCloud.
	icloud="$HOME/Library/Mobile Documents/"'com~apple~CloudDocs/'
	if [ -f ./tracks.db ] && [ -d "$icloud" ]; then rsync -avzPhLu tracks.db "$icloud"; else echo "skipping icloud backup: not exist: ./tracks.db || $icloud"; fi

	# Tar and gzip preexisting out.json and out.mbtiles files.
	if [ -f ./out.json ] && [ -f ./out.mbtiles ]; then
		if [ -f ./out.bak.tar.gz ]; then mv ./out.bak.tar.gz ./out.bak.tar.gz.bak; fi
		gzip -v -9 ./out.json
		gzip -v -9 ./out.mbtiles
		tar -zcvf out.bak.tar.gz ./out.json.gz ./out.mbtiles.gz
		rm out.json.gz out.mbtiles.gz
    rm ./*.json.gz
	fi

	# Remove raw tippedcanoetrack.db
	if [ -f ./tippedcanoetrack.db ]; then rm ./tippedcanoetrack.db; fi

	# Shift preexisting gzipped tippedcanoetrack.db.gz to .bak
	if [ -f ./tippedcanoetrack.db.gz ]; then mv ./tippedcanoetrack.db.gz ./tippedcanoetrack.db.gz.bak; fi
}

while getopts 'nsx:' flag; do
	case "${flag}" in
	n) noupdatedb=1 ;;
	s) noupdatedeps=1 ;;
	x) jumpto="${OPTARG}" ;;
	*) echo "Unexpected option ${flag}" && exit 1 ;;
	esac
done

if [ "$jumpto" != "" ]; then
	case "$jumpto" in
	upload) upload && exit 0 ;;
	syncfrom) syncfrom && exit 0 ;;
	cleanup) cleanup && exit 0 ;;
	dump) dumpify && exit 0 ;;
	*) echo "unknown optarg:$jumpto" && exit 1 ;;
	esac
fi

syncfrom
cleanup
dumpify
upload


