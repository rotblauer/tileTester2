#!/usr/bin/env bash

upload() {

	# Gzip it for uploading
	echo "------------------------------------------"
	echo "gzipping tippedcanoetrack.db -> tippedcanoetrack.db.gz for uploading..."
	echo
	gzip --best --keep --verbose ./tippedcanoetrack.db

	# sync newly created/update bolty db back to punktlich, finally
	echo "------------------------------------------"
	echo "** Syncing fresh bolt.db back to punktlich.rotblauer.com..."
	echo
	rsync -avzLh --progress ./tippedcanoetrack.db.gz freya:~/punktlich.rotblauer.com/tippedcanoetrack.db.gz #/tester.db

	# And update locally too for development.
	echo "------------------------------------------"
	echo "Copying fresh tippedcanoetrack.db -> TileServer/tester.db..."
	echo
	cp tippedcanoetrack.db ./TileServer/tester.db

	echo "------------------------------------------"
	echo "Replacing old db with new db on Freya and kickstarting tile server..."
	echo

	ssh freya <<\EOI
cd punktlich.rotblauer.com
gzip --decompress ./tippedcanoetrack.db.gz
mv ./tippedcanoetrack.db ./tester.db
./kickstart
exit
EOI

}

# verbose='false'
# aflag=''
# bflag=''
# uflag=''

# while getopts 'abf:v' flag; do
#   case "${flag}" in
#     a) aflag='true' ;;
#     b) bflag='true' ;;
#     f) files="${OPTARG}" ;;
#     v) verbose='true' ;;
#     *) error "Unexpected option ${flag}" ;;
#   esac
# done

noupdateflag=0   # update tracks.db (rsync from server), default true
skipupdatedeps=0 # don't update project dependencies, eg ! go get -u ...
jumpto=''
while getopts 'nsx:' flag; do
	case "${flag}" in
	n) noupdateflag=1 ;;
	s) skipupdatedeps=1 ;;
	x) jumpto="${OPTARG}" ;;
	*) error "Unexpected option ${flag}" ;;
	esac
done

if [ "$jumpto" != "" ]; then
	case "$jumpto" in
		upload) upload && exit 0 ;;
	esac
fi

if [[ -f backup ]]; then
	echo "------------------------------------------"
	echo "Backup up tracks.db -> iCloud..."
	./backup
fi

# # The Overview
# server tracks.db(bolt) -> local tippecanoe -> local out.mbtiles (+ out.json) -> local tippedcanoetrack.db(bolt) -> server punktlich.rotblauer.com/
if [[ noupdateflag -eq 0 ]]; then

	# update copy of freya from which to sync from... this should keep
	# the sync-from version relatively static...? (as opposed to syncing from a "live" db)
	# also defacto backup
	ssh freya <<\EOI
kill $(ps aux | grep [t]rackermain | awk '{print $2}')
cd track.areteh.co
rsync -avzLh --delete --progress ./db/tracks.db ./tracks.db.sync
./kickstart
exit
EOI

	echo "Moving tracks.db -> tracks.db.bak"
	# make a backup/remove old local version. don't want any stragglers causing problems with bolt opening file.
	mv ./tracks.db ./tracks.db.bak
	# update tracks from API bolt.db on Freya to local
	echo "------------------------------------------"
	echo "Syncing remote tracks.db.sync --> local..."
	echo
	rsync -avzLh --progress freya:~/track.areteh.co/tracks.db.sync ./tracks.db #sync from upstream static copy
else
	if [[ ! -f "./tracks.db" ]]; then
		echo "No local ./tracks.db found and -n flag used to prevent sync from freya. Exiting now."
		exit 1
	fi
	echo "Skipping sync tracks.db from freya; using local tracks.db"
fi

# # Specifics
# ^ tracks.db is bolt database for API that receives incoming tracks from mobile cat trackering devices. catmobileTracks ios.
#    those points are stored as struct trackPoint.TrackPoints.

# tldr
# dump.go runs tracks.db(bolty) through `$ tippecanoe` which builds sensible vector mbtiles
# that .mbtiles file is then transferred back to a bolt.db file and sent back up to serve.
#
# !tldr
# v tippecanoe is a C++ cli program that organizes and builds points to vector mbtiles. it does a lot of logic about how to show a lot of points cleverly. there are options.
#    data generated is in .mbtiles format and .json. .mbtiles is readable by a sqlite3 interface, and tile data is gzipped.
#
# last step of dump.go is undump/undump.go, which reads the .mbtiles/sqlite3 data back into a bolt.db
# that .db (named tippedcanoetrack.db by default) is then synced to the punktlich.rotblauer.com domain as tester.db
#
# punktlich runs a tile server (by default on port :8081?think).
# after running ./getem, you'll need to ssh freya and ./punktlich.rotblauer.com/kickstart for the changes to take effect

# Clear out old out.json/mbtiles. Was getting 'tippecanoe: create metadata table: table metadata already exists'
echo "------------------------------------------"
echo "Cleaning up old artifacts..."
echo
rm ./out*
rm ./tippedcanoetrack.db    # in case there's some smudgeying due to CTRL-Cing during a gettingem or something. tabulara rastafaria n all dat
rm ./tippedcanoetrack.db.gz #ibid, plus gzip always asks to replace

# exit if any error
set -e

echo "------------------------------------------"
echo "Running dump.go..."
echo
rebuild=1
if [[ -f "dumper" ]]; then
	read -p "Found pre-existing 'dumper' binary (built from dump.go). Rebuild? (y/n)? " choice
	case "$choice" in
	y | Y) echo ;;
	n | N) echo "Skipping rebuild of dump.go -> ./dumper ..." && echo && rebuild=0 ;;
	*) echo "Invalid choice." && exit 1 ;;
	esac
fi
if [[ rebuild -eq 1 ]]; then
	# Get and update all dependencies, eg. boltdb/bolt -> coreos/bbolt
	# use github as upstream remote "origin" because goggable dies on the reg now cuz the russians AND not https
	# you HAVE TO ensure that origin is available and secure
	if [[ skipupdatedeps -eq 0 ]]; then
		git --work-tree="$GOPATH/src/github.com/rotblauer/trackpoints" --git-dir="$GOPATH/src/github.com/rotblauer/trackpoints/.git" \
			branch --set-upstream-to=origin/master master
		git branch --set-upstream-to=origin/master master
		echo "> go get -v -u github.com/rotblauer/tileTester2/..."
		go get -v -u github.com/rotblauer/tileTester2/...
	fi

	echo "> go build -o dumper dump.go ..."
	go build -o dumper dump.go
fi
./dumper
upload

# FIXME:
# ./getem: line 173: unexpected EOF while looking for matching `"'
